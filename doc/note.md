内存规划:
80010000~800C0000:MAIN.EXE
8018A000~?:压缩图像
801f6000~?:解压后的图像


LOAD	0D5D54:65 - sprite (24, 16)*(48, 16) clut(496, 728), UV(24, 48) RGB( 0,  0,  0)  
SAVE	0C1D54:65 - sprite (24, 16)*(48, 16) clut(496, 728), UV(72, 48) RGB( 0,  0,  0)
CLEAR clut=496,217
0C9D8C:2D - FT4 (185, 42)*(16, 16) clut(496, 729) TP(384, 0)(bit:0) UV<(418, 32)*(8, 16)>(136, 32)*(8, 16) RGB(C0, C0, 90)   //!
0C9D3C:2D - FT4 (140, 42)*(16, 16) clut(496, 729) TP(384, 0)(bit:0) UV<(406, 32)*(16, 16)>(88, 32)*(16, 16) RGB(CB,  0, 3F)  //ri
0C9D64:2D - FT4 (163, 47)*(16, 16) clut(496, 729) TP(384, 0)(bit:0) UV<(410, 32)*(16, 16)>(104, 32)*(16, 16) RGB(C0, C0, 90) //a
0C9D14:2D - FT4 (119, 51)*(16, 16) clut(496, 729) TP(384, 0)(bit:0) UV<(402, 32)*(16, 16)>(72, 32)*(16, 16) RGB(F0, 90,  0)  //ku


=====================================
光盘格式:
每个LBA=2352个字节
=====================================

脚本结构：
个数 + N个指针 + FFFF + N段文本
2Bytes - unknown
2Bytes - pointer个数+1
12Bytes - 0

2Bytes - 某个文本段的相对起始位置
2Bytes - unknown
最后跟上FFFF代表结束
最后再补齐FF至16字节的倍数

==========TOMBA2.IMG格式==================
titlebg位置: tomba2.img 0x34800~0x46510
图像头(0x800)+图像体(压缩)
图像头格式:4B(?)+4B(upload to vram XY)+4B(w,h)

=================
MAIN.EXE
F14~57f2:一串文本串,对应在内存中的地址为:80010714~80014ff2,包括任务标题跳出块/菜单/地点等,每个文本串以00做结束符,
这些文本串的指针串散落在MAIN.EXE各处,例如94794有一片,指针格式为这些文本串所在的内存地址.

=================
对话框的背景和边框根据文本长度自动生成，屏幕上每行最多19个字符

=================
crystaltile2查看：
使用jp.gbk.tbl做码表，勾选“翻转编码”


=================
bios结构
每个字符宽16高15，占30B
字库起始地址：0x66000, 映射地址为:BFC66000, 共3489字符

日文五十音起始地址:0x6787e
汉字起始地址:


=====菜单字库相关=====================
1. 字符编码与坐标对应关系
82E9=る, x=(30H&1f)<<3=80H, y=(30H>>>5)*8=8, 源数据30H来自于800A6F78,这个地址上的数据为c872010830,前一个字是内存地址,指向的正是82E9
loc_8007943c:把30转换为坐标.
坐标区位于:800a6fbc~800a7523,1383个字节,173组坐标. 可扩容4倍即692字,或者放345条CPU指令
坐标格式:每8字节一组, 前4个字节代表字符编码所在内存地址,后4个字节代表XY
修改方案:0x/1x对应第1行字符,2x/3x对应第2行,依此类推,根据字符编码即可计算出坐标,每页能存200个字符. 把新的ASM代码放到坐标区.

2. 菜单字库的材质页确定
loc_80079548的80079558 : ADDIU   80014b74 (a3), 00000000 (r0), 001f (31)  //定义材质页坐标为1f , //TODO 要改成1e

3. 菜单字库的色板确定
8003489c : ADDIU   800ea100 (a0), 00000000 (r0), 0100 (256),
800348a0 : ADDIU   00000000 (a1), 00000000 (r0), 001c (28),
800348a4 : LW      0000001f (a3), 0014 (800a5188 (s0)) [800a519c]
800348a8 : ADDIU   00000000 (a2), 00000000 (r0), 0014 (20),//确定clut.y的偏移量
800348ac : SW      00000064 (s1), 0010 (801fe8d0 (sp)) [801fe8e0]
800348b0 : JAL     8007936c, 8003489c (ra),
800348b4 : NOP    

8007936c : ADDIU   801fe8d0 (sp), 801fe8d0 (sp), ffc8 (65480),
80079370 : SW      800a5188 (s0), 0018 (801fe898 (sp)) [801fe8b0]
80079374 : ADDU    800a5188 (s0), 80014b74 (a3), 00000000 (r0),
80079378 : SW      80101e28 (s2), 0020 (801fe898 (sp)) [801fe8b8]
8007937c : LUI     80101e28 (s2), 1f80 (8064),
80079380 : ORI     1f800000 (s2), 1f800000 (s2), 0020 (32),
80079384 : SW      00000000 (s6), 0030 (801fe898 (sp)) [801fe8c8]
80079388 : LW      00000000 (s6), 0048 (801fe898 (sp)) [801fe8e0]
8007938c : ADDIU   00000025 (v0), 00000000 (r0), 0075 (117),
80079390 : SW      00000000 (s5), 002c (801fe898 (sp)) [801fe8c4]
80079394 : ADDU    00000000 (s5), 00000100 (a0), 00000000 (r0),
80079398 : SW      800348b8 (ra), 0034 (801fe898 (sp)) [801fe8cc]
8007939c : SW      0000001c (s4), 0028 (801fe898 (sp)) [801fe8c0]
800793a0 : SW      00000064 (s3), 0024 (801fe898 (sp)) [801fe8bc]
800793a4 : SW      00000064 (s1), 001c (801fe898 (sp)) [801fe8b4]
800793a8 : SB      00000075 (v0), 0007 (1f800020 (s2)) [1f800027]
800793ac : SLTI    00000075 (v0), 00000014 (a2), 0010 (16),
800793b0 : SH      00000100 (a0), 0008 (1f800020 (s2)) [1f800028]
800793b4 : BNE     00000000 (v0), 00000000 (r0), 800793cc,
800793b8 : SH      0000001c (a1), 000a (1f800020 (s2)) [1f80002a]
800793bc : ADDIU   00000000 (v0), 00000014 (a2), 01e0 (480),//clut.y=500=14H+1E0,不确定应该修改哪个值以改动Y
800793c0 : SLL     000001f4 (v0), 000001f4 (v0), 06 (6),//clut.y=0x1f4, 要左移6位和clut.y并成2个字节
800793c4 : J       800793d8,
800793c8 : ORI     00007d00 (v0), 00007d00 (v0), 003e (62),//clut.x=992=16*3e

800793d8 : SH      00007d3e (v0), 000e (1f800020 (s2)) [1f80002e]	//最终的色板即为7d3e,保存起来供显存指令生成函数取出并写入显存指令

3. 显存指令生成
loc_8007943C:把scratch pad中保存的指令书写到packet区域.
修改方案: sprite8x8改成sprite10x10,根据字符编码确定色板(例如81xx对应色板1,82xx对应色板2,83xx对应色板3,84xx对应色板4)




=====第2字库的显示过程===============
0024=み,　x=(0024&0x1f)*8, y=(0024>>>5)<<3=8
数字为内码+0x4f, 4f来自80079C58
MAIN.EXE. func8004f530功能:书写显存DMA指令,把编码转换为坐标 
指定材质页:8004f608:1f改成1e
色板: 
	水色(1008,498)因子2,&38bec
	粉色(1008,499)因子3,&38bf0
	绿色(1008,500)因子4,&389d8
	蓝色(1008,501)因子5,&38be4

流程:读取到菜单字库的字符编码,根据字典表,把字符编码转成UV,写入临时内存区域801fxxxx. DMA程序之后读取此临时内存,把UV转成sprite





//整体功能:把UV转成DMA指令, s1=next link head addr
8004f530 : BEQ     00000026 (v1), 0000ff02 (v0), 8004f5dc, //如果是ff02空格,直接跳到8004f5dc,x+=8
8004f534 : ADDIU   0000ff02 (v0), 00000000 (r0), 0075 (117),
8004f538 : SB      00000075 (v0), fffa (000c1d5d (a1)) [000c1d57] //write sprite8*8 code
8004f53c : LHU     00000075 (v0), 0000 (800c1344 (s0)) [800c1344] //v0=UV
8004f540 : NOP    
8004f544 : ADDIU   00000026 (v0), 00000026 (v0), fef7 (65271), //4行,是否使用默认clut 7c3e
8004f548 : SLTIU   ffffff1d (v0), ffffff1d (v0), 0003 (3),
8004f54c : BNE     00000000 (v0), 00000000 (r0), 8004f564, 
8004f550 : ADDIU   00000000 (v0), 00000000 (r0), 7c3e (31806),

8004f554 : ANDI    00007c3e (v0), 00000000 (a3), 00ff (255),//4行,决定clut
8004f558 : ADDIU   00000000 (v0), 00000000 (v0), 01f0 (496),
8004f55c : SLL     000001f0 (v0), 000001f0 (v0), 06 (6),
8004f560 : ORI     00007c00 (v0), 00007c00 (v0), 003f (63),

8004f564 : SH      00007c3f (v0), 0001 (000c1d5d (a1)) [000c1d5e] //write clut
8004f568 : SH      00000036 (a2), fffb (000c1d5d (a1)) [000c1d58] //write x
8004f56c : SH      0000009e (s3), fffd (000c1d5d (a1)) [000c1d5a] //write y
8004f570 : LHU     00007c3f (v0), 0000 (800c1344 (s0)) [800c1344] //4行,calculate u
8004f574 : NOP    
8004f578 : ANDI    00000026 (v0), 00000026 (v0), 001f (31),
8004f57c : SLL     00000006 (v0), 00000006 (v0), 03 (3),
8004f580 : SB      00000030 (v0), ffff (000c1d5d (a1)) [000c1d5c] //write u
8004f584 : LHU     00000030 (v0), 0000 (800c1344 (s0)) [800c1344] //4行,calculate v
8004f588 : NOP    
8004f58c : SRL     00000026 (v0), 00000026 (v0), 05 (5),
8004f590 : SLL     00000001 (v0), 00000001 (v0), 03 (3),
8004f594 : SB      00000008 (v0), 0000 (000c1d5d (a1)) [000c1d5d] //write v
8004f598 : LUI     00000008 (v0), 800f (32783),					  //4行,load last saved link head
8004f59c : LW      800c137c (a0), f570 (800f0000 (v0)) [800ef570]
8004f5a0 : NOP    
8004f5a4 : LW      800f0000 (v0), 000c (800e9f70 (a0)) [800e9f7c]
8004f5a8 : LUI     00000026 (v1), 0300 (768),					  //2行:拼接完整的link head
8004f5ac : OR      000e9f78 (v0), 000e9f78 (v0), 03000000 (v1),
8004f5b0 : SW      030e9f78 (v0), 0000 (000c1d50 (s1)) [000c1d50] //write link head
8004f5b4 : SW      000c1d50 (s1), 000c (800e9f70 (a0)) [800e9f7c] //update saved link head
8004f5b8 : ADDIU   000c1d5d (a1), 000c1d5d (a1), 0010 (16), //dma size+=16
8004f5bc : LHU     030e9f78 (v0), 0000 (800c1344 (s0)) [800c1344] //5行,判断UV是否大于0105,是的话宽度为5
8004f5c0 : NOP    
8004f5c4 : ADDIU   00000026 (v0), 00000026 (v0), fef9 (65273),
8004f5c8 : SLTIU   ffffff1f (v0), ffffff1f (v0), 0002 (2),
8004f5cc : BEQ     00000000 (v0), 00000000 (r0), 8004f5dc,
8004f5d0 : ADDIU   000c1d50 (s1), 000c1d50 (s1), 0010 (16), //next link head addr += 16

分支1//8004f5d4 : J 8004f5e0
分支1//8004f5d8 : ADDIU a2,a2,5 //X递增5
分支2 8004f5dc : ADDIU   00000036 (a2), 00000036 (a2), 0008 (8), //X递增8

8004f5e0 : ADDIU   800c1344 (s0), 800c1344 (s0), 0002 (2),
8004f5e4 : LHU     03000000 (v1), 0000 (800c1346 (s0)) [800c1346]
8004f5e8 : ORI     00000000 (v0), 00000000 (r0), ffff (65535),
8004f5ec : BNE     0000000b (v1), 0000ffff (v0), 8004f510,
8004f5f0 : ADDIU   0000ffff (v0), 0000000b (v1), 00f0 (240),
8004f510 : ANDI    000000fb (v0), 000000fb (v0), ffff (65535),
8004f514 : SLTIU   000000fb (v0), 000000fb (v0), 0008 (8),
8004f518 : BEQ     00000000 (v0), 00000000 (r0), 8004f530,
8004f51c : ORI     00000000 (v0), 00000000 (r0), ff02 (65282),
